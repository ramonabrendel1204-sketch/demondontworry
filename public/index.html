<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Horror Ludo Deluxe</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Roboto:wght@400;700&display=swap');

        body { margin: 0; overflow: hidden; font-family: 'Roboto', sans-serif; background-color: #050505; color: #eee; }
        
        /* UI LAYOUT */
        #hud-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .hud-panel {
            background: rgba(20, 0, 0, 0.9);
            border: 2px solid #660000;
            padding: 10px 20px; margin: 20px;
            border-radius: 5px;
            pointer-events: auto;
            box-shadow: 0 0 15px rgba(0,0,0,0.9);
        }

        .top-row { display: flex; justify-content: space-between; align-items: flex-start; }
        #identity h2 { margin: 0; color: #fff; font-family: 'Creepster', cursive; letter-spacing: 1px; }
        #timer-box { font-size: 3rem; font-weight: bold; color: #ff0000; text-shadow: 0 0 10px red; }

        .bottom-row { display: flex; justify-content: center; padding-bottom: 30px; pointer-events: auto; }
        #status-msg { 
            font-size: 1.2rem; margin-bottom: 10px; font-weight: bold; text-align: center;
            text-shadow: 2px 2px 0 #000; background: rgba(0,0,0,0.8); padding: 8px 15px; border-radius: 5px;
            border: 1px solid #440000;
        }

        .btn-horror {
            background: linear-gradient(to bottom, #990000, #550000);
            border: 2px solid #ff3333; color: white;
            padding: 15px 40px; font-size: 1.8rem;
            font-family: 'Creepster', cursive; cursor: pointer;
            border-radius: 8px; box-shadow: 0 0 20px rgba(255,0,0,0.4);
        }
        .btn-horror:disabled { filter: grayscale(100%); opacity: 0.5; }

        /* SCREENS */
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 0, 0, 0.98); z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .hidden { display: none !important; }
        
        input { padding: 15px; background: #111; border: 2px solid #444; color: white; text-align: center; font-size: 1.2rem; margin-bottom: 20px; }
        
        .quiz-opt {
            background: #222; border: 1px solid #444; padding: 15px; margin: 10px; width: 80%; max-width: 400px;
            cursor: pointer; text-align: center; font-size: 1.1rem;
        }
        .quiz-opt:hover { background: #660000; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>

    <div id="hud-container">
        <div class="top-row">
            <div class="hud-panel" id="identity">
                <small>Deine Figur:</small>
                <h2 id="my-name">Geist</h2>
                <div id="my-color-dot" style="width:100%; height:4px; background:grey; margin-top:5px;"></div>
            </div>
            <div class="hud-panel" id="turn-info">
                <small>Am Zug:</small>
                <h2 id="turn-name" style="color:gold">---</h2>
                <div id="timer-box">15</div>
            </div>
        </div>
        <div class="bottom-row">
            <div>
                <div id="status-msg">Verbindung wird hergestellt...</div>
                <button id="btn-action" class="btn-horror" style="display:none;">WÜRFELN</button>
            </div>
        </div>
    </div>

    <div id="login-screen" class="overlay">
        <h1 style="font-family: 'Creepster'; color: red; font-size: 4rem;">Horror Ludo</h1>
        <input type="text" id="room-id" value="Friedhof1">
        <button class="btn-horror" onclick="connect()">Beitreten</button>
    </div>

    <div id="lobby-screen" class="overlay hidden">
        <h1 style="color:red; font-family:'Creepster'">Warteraum</h1>
        <div id="lobby-list" style="margin: 20px; font-size: 1.2rem;"></div>
        <button id="btn-start" class="btn-horror" onclick="startGame()" disabled>Warte auf Host...</button>
    </div>

    <div id="quiz-screen" class="overlay hidden">
        <h2 style="color:red; font-family:'Creepster'">Todesfrage</h2>
        <p id="q-text" style="font-size:1.5rem; padding: 20px; text-align:center;"></p>
        <div id="q-opts" style="width: 100%; display: flex; flex-direction: column; align-items: center;"></div>
    </div>

    <script>
        const socket = io();
        const COLORS_HEX = { red: 0x880000, blue: 0x000088, green: 0x004400, yellow: 0xcccc00 };
        const QUESTIONS = [
            { q: "Wer führte Regie bei 'Psycho'?", a: ["Hitchcock", "Spielberg", "Carpenter"], c: 0 },
            { q: "Wie heißt der Killer in 'Scream'?", a: ["Ghostface", "Leatherface", "Pinhead"], c: 0 },
            { q: "Waffe von Freddy Krueger?", a: ["Krallenhandschuh", "Kettensäge", "Machete"], c: 0 }
        ];

        let myData = { color: 'red', figure: '', isHost: false };
        let gameInstance = null;

        function connect() {
            const r = document.getElementById('room-id').value;
            socket.emit('joinGame', r);
        }

        function startGame() {
            socket.emit('requestStartGame', document.getElementById('room-id').value);
        }

        socket.on('setIdentity', data => {
            myData = data;
            document.getElementById('my-name').innerText = data.figure;
            document.getElementById('my-name').style.color = '#' + COLORS_HEX[data.color].toString(16).padStart(6, '0');
            document.getElementById('my-color-dot').style.backgroundColor = '#' + COLORS_HEX[data.color].toString(16).padStart(6, '0');
            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('lobby-screen').classList.remove('hidden');
        });

        socket.on('lobbyUpdate', data => {
            document.getElementById('lobby-list').innerHTML = data.players.map(p => 
                `<div style="color:${p.color}">${p.name}</div>`
            ).join('');
            if(data.hostId === socket.id) {
                const b = document.getElementById('btn-start');
                b.disabled = false; b.innerText = "SPIEL STARTEN";
            }
        });

        socket.on('gameStarted', data => {
            document.getElementById('lobby-screen').classList.add('hidden');
            if(!gameInstance) gameInstance = new GameEngine(data);
        });

        class GameEngine {
            constructor(data) {
                this.initThree();
                this.trapFields = data.trapFields;
                this.board = new GameBoard(this.scene, this.trapFields);
                this.dice = new DiceObject(this.scene);
                this.pieces = [];
                this.rollCount = 0;
                this.currentRolled = null;
                this.activeColor = '';

                data.players.forEach(p => {
                    for(let i=0; i<4; i++) this.pieces.push(new GamePiece(p.color, i, this.scene, this.board));
                });

                this.setupEvents();
                this.animate();
            }

            initThree() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x050505);
                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 1000);
                this.camera.position.set(0, 50, 45);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.body.appendChild(this.renderer.domElement);

                this.scene.add(new THREE.AmbientLight(0xffffff, 0.5));
                const sun = new THREE.DirectionalLight(0xffffff, 0.7);
                sun.position.set(10, 50, 10);
                this.scene.add(sun);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.raycaster = new THREE.Raycaster();
            }

            setupEvents() {
                socket.on('turnChanged', d => {
                    this.activeColor = d.activeColor;
                    this.currentRolled = null;
                    this.rollCount = 0;
                    document.getElementById('turn-name').innerText = d.activeName;
                    document.getElementById('turn-name').style.color = '#' + COLORS_HEX[d.activeColor].toString(16).padStart(6, '0');
                    
                    const btn = document.getElementById('btn-action');
                    if(d.activeColor === myData.color) {
                        btn.style.display = 'block';
                        btn.onclick = () => {
                            btn.style.display = 'none';
                            socket.emit('rollDice', { roomId: document.getElementById('room-id').value });
                        };
                        document.getElementById('status-msg').innerText = "Deine Runde!";
                    } else {
                        btn.style.display = 'none';
                        document.getElementById('status-msg').innerText = d.activeName + " ist am Zug...";
                    }
                });

                socket.on('diceRolled', d => {
                    this.dice.rollAnimation(d.value, () => {
                        if(d.playerId === socket.id) {
                            this.currentRolled = d.value;
                            this.rollCount++;
                            this.handleLocalRoll(d.value);
                        }
                    });
                });

                socket.on('pieceMoved', d => {
                    const p = this.pieces.find(x => x.color === this.activeColor && x.id === d.pieceId);
                    if(p) p.updatePos(d.newPosition);
                });

                this.renderer.domElement.addEventListener('mousedown', e => this.handleInput(e));
            }

            handleLocalRoll(val) {
                const piecesAtHome = this.pieces.filter(p => p.color === myData.color && p.pos === -1).length;
                const piecesOut = this.pieces.filter(p => p.color === myData.color && p.pos >= 0).length;

                if(val !== 6 && piecesOut === 0 && this.rollCount < 3) {
                    document.getElementById('status-msg').innerText = `Keine 6 (Versuch ${this.rollCount}/3). Nochmal!`;
                    document.getElementById('btn-action').style.display = 'block';
                } else if (!this.canAnyMove(val)) {
                    document.getElementById('status-msg').innerText = "Kein Zug möglich!";
                    setTimeout(() => socket.emit('endTurn', { roomId: document.getElementById('room-id').value }), 1500);
                } else {
                    document.getElementById('status-msg').innerText = `Gewürfelt: ${val}. Figur wählen!`;
                }
            }

            canAnyMove(val) {
                return this.pieces.filter(p => p.color === myData.color).some(p => {
                    if(p.pos === -1) return val === 6;
                    return (p.pos + val) <= 43;
                });
            }

            handleInput(e) {
                if(!this.currentRolled || this.activeColor !== myData.color) return;
                const m = new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
                this.raycaster.setFromCamera(m, this.camera);
                const hits = this.raycaster.intersectObjects(this.scene.children, true);
                for(let h of hits) {
                    let o = h.object;
                    while(o && !o.userData.piece) o = o.parent;
                    if(o && o.userData.piece.color === myData.color) {
                        this.executeMove(o.userData.piece);
                        break;
                    }
                }
            }

            executeMove(p) {
                let target = -1;
                if(p.pos === -1) {
                    if(this.currentRolled === 6) target = 0; else return;
                } else {
                    target = p.pos + this.currentRolled;
                    if(target > 43) return;
                }
                
                socket.emit('movePiece', { roomId: document.getElementById('room-id').value, pieceId: p.id, newPosition: target });
                
                // Quiz Check
                const abs = this.board.getAbs(target, p.color);
                if(this.trapFields.includes(abs) && target < 40) {
                    this.triggerQuiz(p);
                } else {
                    if(this.currentRolled === 6) {
                        this.currentRolled = null;
                        document.getElementById('btn-action').style.display = 'block';
                        document.getElementById('status-msg').innerText = "Noch mal würfeln!";
                    } else {
                        socket.emit('endTurn', { roomId: document.getElementById('room-id').value });
                    }
                }
            }

            triggerQuiz(p) {
                const s = document.getElementById('quiz-screen');
                s.classList.remove('hidden');
                const q = QUESTIONS[Math.floor(Math.random()*QUESTIONS.length)];
                document.getElementById('q-text').innerText = q.q;
                const o = document.getElementById('q-opts');
                o.innerHTML = '';
                q.a.forEach((txt, i) => {
                    const b = document.createElement('div');
                    b.className = 'quiz-opt'; b.innerText = txt;
                    b.onclick = () => {
                        s.classList.add('hidden');
                        if(i !== q.c) {
                            socket.emit('movePiece', { roomId: document.getElementById('room-id').value, pieceId: p.id, newPosition: -1 });
                        }
                        socket.emit('endTurn', { roomId: document.getElementById('room-id').value });
                    };
                    o.appendChild(b);
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }

        class GameBoard {
            constructor(scene, traps) {
                this.scene = scene;
                this.traps = traps;
                this.create();
            }
            create() {
                const base = new THREE.Mesh(new THREE.BoxGeometry(55, 1, 55), new THREE.MeshStandardMaterial({color: 0x111111}));
                base.position.y = -0.5;
                this.scene.add(base);

                for(let i=0; i<40; i++) {
                    const pos = this.calcPos(i);
                    const isTrap = this.traps.includes(i);
                    const mat = new THREE.MeshStandardMaterial({color: isTrap ? 0x660066 : 0x333333});
                    const tile = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.2, 2.5), mat);
                    tile.position.copy(pos);
                    this.scene.add(tile);
                }

                ['red','blue','green','yellow'].forEach(c => {
                    for(let i=0; i<4; i++) {
                        const pos = this.calcSafePos(i, c);
                        const tile = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.3, 2.5), new THREE.MeshStandardMaterial({color: COLORS_HEX[c], transparent: true, opacity: 0.5}));
                        tile.position.copy(pos);
                        this.scene.add(tile);
                    }
                });
            }
            calcPos(i) {
                const arm = Math.floor(i/10);
                const step = i%10;
                let x=0, z=0;
                if(step < 5) { x = 2.8; z = (5-step)*2.8; }
                else { x = (step-3)*2.8; z = 2.8; }
                const angle = -arm * (Math.PI/2);
                return new THREE.Vector3(x*Math.cos(angle)-z*Math.sin(angle), 0.1, x*Math.sin(angle)+z*Math.cos(angle));
            }
            calcSafePos(i, color) {
                let rot = {red:0, blue:1, green:2, yellow:3}[color];
                const v = new THREE.Vector3(0, 0.1, (4-i)*2.8);
                const angle = -rot * (Math.PI/2);
                return new THREE.Vector3(v.x*Math.cos(angle)-v.z*Math.sin(angle), 0.1, v.x*Math.sin(angle)+v.z*Math.cos(angle));
            }
            getAbs(i, color) {
                let off = {red:0, blue:10, green:20, yellow:30}[color];
                return (i + off) % 40;
            }
            getCoords(i, color) {
                if(i === -1) {
                    let x = color==='red'||color==='blue'?15:-15;
                    let z = color==='red'||color==='yellow'?15:-15;
                    return new THREE.Vector3(x, 0, z);
                }
                if(i >= 40) return this.calcSafePos(i-40, color);
                return this.calcPos(this.getAbs(i, color));
            }
        }

        class GamePiece {
            constructor(color, id, scene, board) {
                this.color = color; this.id = id; this.board = board; this.pos = -1;
                this.mesh = new THREE.Group();
                this.mesh.userData = { piece: this };
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1, 2.5, 8), new THREE.MeshStandardMaterial({color: COLORS_HEX[color]}));
                body.position.y = 1.25;
                this.mesh.add(body);
                scene.add(this.mesh);
                this.updatePos(-1);
            }
            updatePos(p) {
                this.pos = p;
                const target = this.board.getCoords(p, this.color);
                if(p === -1) {
                    target.x += (this.id%2===0 ? -2:2);
                    target.z += (this.id<2 ? -2:2);
                }
                this.mesh.position.copy(target);
            }
        }

        class DiceObject {
            constructor(scene) {
                this.mesh = new THREE.Mesh(new THREE.BoxGeometry(3,3,3), new THREE.MeshStandardMaterial({color: 0xffffff}));
                this.mesh.position.set(0, 10, 0);
                scene.add(this.mesh);
            }
            rollAnimation(val, cb) {
                let count = 0;
                const i = setInterval(() => {
                    this.mesh.rotation.x += 0.4; this.mesh.rotation.y += 0.4;
                    if(count++ > 20) {
                        clearInterval(i);
                        this.mesh.rotation.set(0,0,0);
                        if(val === 1) this.mesh.rotation.y = Math.PI/2;
                        if(val === 6) this.mesh.rotation.x = Math.PI/2;
                        cb();
                    }
                }, 40);
            }
        }
    </script>
</body>
</html>

